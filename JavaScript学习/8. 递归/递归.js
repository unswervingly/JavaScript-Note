// 程序调用自身的编程技巧称为递归(recursion)。

// 以阶乘为例：
function factorial(n) {
    if (n == 1) return n;
    return n * factorial(n - 1)
}

console.log(factorial(5)) // 5 * 4 * 3 * 2 * 1 = 120

// 斐波那契数列
function fibonacci(n) {
    return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
}

console.log(fibonacci(5)) // 1 1 2 3 5


/*
    从这两个例子中，我们可以看出：
    构成递归需具备边界条件、递归前进段和递归返回段，当边界条件不满足时，递归前进，当边界条件满足时，递归返回。阶乘中的 n == 1 和 斐波那契数列中的 n < 2 都是边界条件。

    总结一下递归的特点：

    子问题须与原始问题为同样的事，且更为简单；
    不能无限制地调用本身，须有个出口，化简为非递归状况处理。
*/

/* 
    当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。

    对阶乘函数分析执行的过程，JavaScript 会不停的创建执行上下文压入执行上下文栈，对于内存而言，维护这么多的执行上下文也是一笔不小的开销呐！

    使用 尾调用优化。 
*/

// 尾调用，是指函数内部的最后一个动作是函数调用。该调用的返回值，直接返回给函数。
// 举个例子：

// 尾调用
function f(x) {
    return g(x);
}

// 非尾调用
function f(x) {
    return g(x) + 1;
}
// 并不是尾调用，因为 g(x) 的返回值还需要跟 1 进行计算后，f(x)才会返回值。

// 两者又有什么区别呢？答案就是执行上下文栈的变化不一样。

/*
    尾调用函数执行时的执行上下文栈变化：
    ECStack.push(<f> functionContext);

    ECStack.pop();

    ECStack.push(<g> functionContext);

    ECStack.pop();
*/

/*
    非尾调用函数执行时的执行上下文栈变化：
    ECStack.push(<f> functionContext);

    ECStack.push(<g> functionContext);

    ECStack.pop();

    ECStack.pop();
*/
// 也就说尾调用函数执行时，虽然也调用了一个函数，但是因为原来的的函数执行完毕，执行上下文会被弹出，执行上下文栈中相当于只多压入了一个执行上下文。
// 然而非尾调用函数，就会创建多个执行上下文压入执行上下文栈。

// 函数调用自身，称为递归。如果尾调用自身，就称为尾递归。

// 所以我们只用把阶乘函数改造成一个尾递归形式，就可以避免创建那么多的执行上下文。