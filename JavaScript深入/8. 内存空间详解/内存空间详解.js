// 栈数据结构
// 栈的结构就是后进先出（LIFO），

// 堆数据结构
// 堆数据结构是一种树状结构。它的存取数据的方式与书架和书非常相似。我们只需要知道书的名字就可以直接取出书了，并不需要把上面的书取出来。

// 队列
// 队列是一种先进先出（FIFO）的数据结构，这是事件循环（Event Loop）的基础结构

/* 
    变量应该存放在哪里呢，堆？栈？

    1、基本类型 --> 保存在栈内存中，因为这些类型在内存中分别占有固定大小的空间，通过按值来访问。
    基本类型一共有6种：Undefined、Null、Boolean、Number 、String和Symbol

    2、引用类型 --> 保存在堆内存中，因为这种值的大小不固定，因此不能把它们保存到栈内存中，
    但内存地址大小的固定的，因此保存在堆内存中，在栈内存中存放的只是该对象的访问地址。
    当查询引用类型的变量时， 先从栈中读取内存地址， 然后再通过地址找到堆中的值。对于这种，我们把它叫做按引用访问。 
*/

// 问题1：

var a = 20;
var b = a;
b = 30;

// 这时a的值是多少？
// 问题2：

var a = { name: '前端开发' }
var b = a;
b.name = '进阶';

// 这时a.name的值是多少
// 问题3：

var a = { name: '前端开发' }
var b = a;
a = null;

// 这时b的值是多少
/* 
    三个问题的答案分别是20、‘进阶’、{ name: '前端开发' }

    对于问题1，a、b都是基本类型，它们的值是存储在栈中的，a、b分别有各自独立的栈空间，所以修改了b的值以后，a的值并不会发生变化。
    对于问题2，a、b都是引用类型，栈内存中存放地址指向堆内存中的对象，引用类型的复制会为新的变量自动分配一个新的值保存在变量对象中，但只是引用类型的一个地址指针而已，实际指向的是同一个对象，所以修改b.name的值后，相应的a.name也就发生了改变。
    对于问题3，首先要说明的是null是基本类型，a = null之后只是把a存储在栈内存中地址改变成了基本类型null，并不会影响堆内存中的对象，所以b的值不受影响。 
*/

/* 
    内存空间管理
    JavaScript的内存生命周期是

    1、分配你所需要的内存
    2、使用分配到的内存（读、写）
    3、不需要时将其释放、归还
    JavaScript有自动垃圾收集机制，最常用的是通过标记清除的算法来找到哪些对象是不再继续使用的，
    使用a = null其实仅仅只是做了一个释放引用的操作，让 a 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。

    在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。
    但是全局变量什么时候需要自动释放内存空间则很难判断，因此在开发中，需要尽量避免使用全局变量。 
*/


// 思考题：
var a = { n: 1 };
var b = a;
a.x = a = { n: 2 };
//1.（.运算符优先级大于=） 先获取等号左侧的a.x，但a.x并不存在，于是JS为（堆内存中的）对象创建一个新成员x，这个成员的初始值为undefined，即 a.x = {n:1,x=undefined}

//2. 接着执行赋值语句的右侧 a = { n: 2 } 
// 这个a已经不是开头的那个a，而是一个全新的a,这个新a指针已经不是指向原来的值的那个堆内存，而是分配了一个新的堆内存。
// 但是原来旧的堆内存因为还有b在占用，所以并未被回收。

//a:指向 
{ n: 2 }
//b指向 
{ n: 1, x = undefined }
// 注：javascript 执行顺序从右往左的

// 3. 接着执行赋值语句 a.x = a 即 a.x = { n : 2 }

// 4. a还保留有b的引用，因此第三步就相当于b.x = { n: 2 }
console.log(a.x); // undefined

console.log(b.x); // { n: 2 }

